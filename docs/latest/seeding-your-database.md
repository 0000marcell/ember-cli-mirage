---
title: Seeding your database
version: latest
---

Once you've defined your server's routes, you'll probably want to seed your database with some starting data. You can use factories or fixtures, or both. 

In general Mirage recommends you use factories, especially for acceptance testing, as they force you to keep data creation logic close to the code that relies on that data. Also, once relationships land, it will be much simpler to create related models using factories.

Some people prefer the simplicity of fixture files, though they can get unwieldy as your app grows.

## Factories

If you've never used factories before, think of them as a simple way to create database records. You define factories by creating files under `/mirage/factories/factory-name.js`. The name of the factory, which you reference in your tests, is determined by the filename.

Factories have attributes which can be strings, numbers or booleans, or functions:

```js
// mirage/factories/user.js
import Mirage from 'ember-cli-mirage';

export default Mirage.Factory.extend({
  name: i => `User ${i}`,
  age: 20,
  admin: false
});
```

Functions take one parameter, the sequence number of the object being created. This lets you create records with dynamic attributes.

Each time this factory is used to create an object, it will have an autogenerated `id` assigned to it, since it will be inserted into the database. So, the objects created from the example factory above will look like

    {id: 1, name: "User 1", age: 20, admin: false}
    {id: 2, name: "User 2", age: 20, admin: false}
    {id: 3, name: "User 3", age: 20, admin: false}

and so on.

To actually use your factories to seed your database, use the `server.create` and `server.createList` methods. In development, create a default scenario file:

```js
// app/mirage/scenarios/default.js
export default function(server) {
  server.createList('user', 10);
}
```

This default scenario will be loaded during development, but ignored during testing. This is so you can change your development data without affecting your tests.

During acceptance testing, Mirage starts each test with a clean database. Use the server methods to define your data on a per-test basis:

```js
test("I can view the users", function() {
  server.createList('user', 3);

  visit('/contacts');

  andThen(function() {
    equal( find('p').length, 3 );
  });
});
```

Learn more about acceptance testing in the next section.

## Fixtures

Think of your fixture files as database tables. If you want to add some data to your `users` table, create the file `/app/mirage/fixtures/users.js`:

```js
// app/mirage/fixtures/users.js
export default [
  {id: 1, name: 'Link'},
  {id: 2, name: 'Zelda'},
  {id: 3, name: 'Epona'}
];
```

<aside class='Docs-page__aside'>
  <p>If you want to use fixtures in testing as well, simply delete your `/mirage/factories` directory.</p>
</aside>

Fixture filenames are always plural, and export arrays of POJOs. Every time your app boots and a Mirage server is instantiated, this data will be added to its database and available in route handlers via `db.users`.

If you want to work with related data, you'll need to manage the foreign keys yourself. You can use whatever convention you like, since you have full access to the db in your route handlers, but let's take a look at a popular convention.

Suppose a `user` has many `addresses`. Your fixture data may look like this:

```js
// app/mirage/fixtures/users.js
export default [
  {id: 1, name: 'Link'},
  {id: 2, name: 'Zelda'}
];

// app/mirage/fixtures/addresses.js
export default [
  {id: 1, name: '123 Hyrule Way', user_id: 1},
  {id: 2, name: '11 Kokiri Forest St.', user_id: 1},
  {id: 3, name: '5 Lost Woods Dr.', user_id: 2}
];
```

Now you can use the shorthand `this.get('/api/users/:id', ['user', 'addresses']`, and Mirage will return the user whose id matches the `:id` route param, along with this user's related addresses - i.e., addresses whose `user_id` matches the param.

